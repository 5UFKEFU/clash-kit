// Objective-C API for talking to ClashKit/clash Go package.
//   gobind -lang=objc ClashKit/clash
//
// File is generated by gobind. Do not edit.

#include <Foundation/Foundation.h>
#include "seq.h"
#include "_cgo_export.h"
#include "Clash.objc.h"


@implementation ClashCPUInfo {
}

- (nonnull instancetype)initWithRef:(_Nonnull id)ref {
	self = [super init];
	if (self) { __ref = ref; }
	return self;
}

- (nonnull instancetype)init {
	self = [super init];
	if (self) {
		__ref = go_seq_from_refnum(new_clash_CPUInfo());
	}
	return self;
}

- (NSString* _Nonnull)modelName {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	nstring r0 = proxyclash_CPUInfo_ModelName_Get(refnum);
	NSString *_r0 = go_seq_to_objc_string(r0);
	return _r0;
}

- (void)setModelName:(NSString* _Nonnull)v {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	nstring _v = go_seq_from_objc_string(v);
	proxyclash_CPUInfo_ModelName_Set(refnum, _v);
}

- (long)cores {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	nint r0 = proxyclash_CPUInfo_Cores_Get(refnum);
	long _r0 = (long)r0;
	return _r0;
}

- (void)setCores:(long)v {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	nint _v = (nint)v;
	proxyclash_CPUInfo_Cores_Set(refnum, _v);
}

@end


@implementation ClashClient {
}

- (nonnull instancetype)initWithRef:(id)ref {
	self = [super init];
	if (self) { __ref = ref; }
	return self;
}

- (void)log:(NSString* _Nullable)level message:(NSString* _Nullable)message {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	nstring _level = go_seq_from_objc_string(level);
	nstring _message = go_seq_from_objc_string(message);
	proxyclash_Client_Log(refnum, _level, _message);
}

- (void)traffic:(int64_t)up down:(int64_t)down {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	int64_t _up = (int64_t)up;
	int64_t _down = (int64_t)down;
	proxyclash_Client_Traffic(refnum, _up, _down);
}

@end



// skipped function GetCPUInfo with unsupported parameter or return types

NSData* _Nullable ClashGetConfigGeneral(void) {
	nbyteslice r0 = proxyclash__GetConfigGeneral();
	NSData *_ret0_ = go_seq_to_objc_bytearray(r0, 1);
	return _ret0_;
}

BOOL ClashPatchSelector(NSData* _Nullable data) {
	nbyteslice _data = go_seq_from_objc_bytearray(data, 0);
	char r0 = proxyclash__PatchSelector(_data);
	if (![data isKindOfClass:[NSMutableData class]]) {
	  free(_data.ptr);
	}
	BOOL _ret0_ = r0 ? YES : NO;
	return _ret0_;
}

void ClashSetup(NSString* _Nullable homeDir, NSString* _Nullable config, id<ClashClient> _Nullable c) {
	nstring _homeDir = go_seq_from_objc_string(homeDir);
	nstring _config = go_seq_from_objc_string(config);
	int32_t _c;
	if ([c conformsToProtocol:@protocol(goSeqRefInterface)]) {
		id<goSeqRefInterface> c_proxy = (id<goSeqRefInterface>)(c);
		_c = go_seq_go_to_refnum(c_proxy._ref);
	} else {
		_c = go_seq_to_refnum(c);
	}
	proxyclash__Setup(_homeDir, _config, _c);
}

void cproxyclash_Client_Log(int32_t refnum, nstring level, nstring message) {
	@autoreleasepool {
		ClashClient* o = go_seq_objc_from_refnum(refnum);
		NSString *_level = go_seq_to_objc_string(level);
		NSString *_message = go_seq_to_objc_string(message);
		[o log:_level message:_message];
	}
}

void cproxyclash_Client_Traffic(int32_t refnum, int64_t up, int64_t down) {
	@autoreleasepool {
		ClashClient* o = go_seq_objc_from_refnum(refnum);
		int64_t _up = (int64_t)up;
		int64_t _down = (int64_t)down;
		[o traffic:_up down:_down];
	}
}

__attribute__((constructor)) static void init() {
	init_seq();
}
